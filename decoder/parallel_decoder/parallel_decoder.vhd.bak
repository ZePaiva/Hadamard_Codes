LIBRARY ieee;
USE ieee.std_logic_1164.all;

ENTITY parallel_decoder IS
  PORT (y: IN STD_LOGIC_VECTOR(7 downto 0);
        m: OUT STD_LOGIC_VECTOR(3 downto 0);
		  v: OUT STD_LOGIC);
END parallel_decoder;

ARCHITECTURE structure OF parallel_decoder IS
	-- decoding computation bits for m3
	SIGNAL m3:	STD_LOGIC;
	SIGNAL m3_c: STD_LOGIC_VECTOR(3 downto 0);
	SIGNAL m3_z: STD_LOGIC;
	SIGNAL m3_o: STD_LOGIC;
	SIGNAL m3_V: STD_LOGIC;
	
	-- decoding computation bits for m2
	SIGNAL m2:	STD_LOGIC;
	SIGNAL m2_c: STD_LOGIC_VECTOR(3 downto 0);
	SIGNAL m2_z: STD_LOGIC;
	SIGNAL m2_o: STD_LOGIC;
	SIGNAL m2_V: STD_LOGIC;
	
	-- decoding computation bits for m1
	SIGNAL m1:	STD_LOGIC;
	SIGNAL m1_c: STD_LOGIC_VECTOR(3 downto 0);
	SIGNAL m1_z: STD_LOGIC;
	SIGNAL m1_o: STD_LOGIC;
	SIGNAL m1_V: STD_LOGIC;
	
	-- decoding computation bits for m0
	SIGNAL m0:	STD_LOGIC;
	SIGNAL m0_c: STD_LOGIC_VECTOR(3 downto 0);
	SIGNAL m0_z: STD_LOGIC;
	SIGNAL m0_o: STD_LOGIC;
	SIGNAL m0_V: STD_LOGIC;
	
	-- genereal decoding computatioin bits
	
BEGIN

	m3_c(0) <= x(0) xor x(1);
	m3_c(1) <= x(2) xor x(3);
	m3_c(2) <= x(4) xor x(5);
	m3_c(3) <= x(6) xor x(7);
	m3_o    <= (m3_c(1) and m3_c(0) and (m3_c(3) or m3_c(2))) or (m3_c(3) and m3_c(2) and (m3_c(1) or m3_c(0)));
	m3_z    <= (not (m3_c(1) or m3_c(0)) and not (m3_c(3) and m3_c(2))) or (not (m3_c(3) or m3_c(2)) and not (m3_c(1) and m3_c(0)));
	m3_v	  <= m3_z xor m3_o;

	m2_c(0) <= x(0) xor x(1);
	m2_c(1) <= x(2) xor x(3);
	m2_c(2) <= x(4) xor x(5);
	m2_c(3) <= x(6) xor x(7);
	m2_o    <= (m2_c(1) and m2_c(0) and (m2_c(3) or m2_c(2))) or (m2_c(3) and m2_c(2) and (m2_c(1) or m2_c(0)));
	m2_z    <= (not (m2_c(1) or m2_c(0)) and not (m2_c(3) and m2_c(2))) or (not (m2_c(3) or m2_c(2)) and not (m2_c(1) and m2_c(0)));
	m2_v	  <= m2_z xor m2_o;

	m1_c(0) <= x(0) xor x(1);
	m1_c(1) <= x(2) xor x(3);
	m1_c(2) <= x(4) xor x(5);
	m1_c(3) <= x(6) xor x(7);
	m1_o    <= (m1_c(1) and m1_c(0) and (m1_c(3) or m1_c(2))) or (m1_c(3) and m1_c(2) and (m1_c(1) or m1_c(0)));
	m1_z    <= (not (m1_c(1) or m1_c(0)) and not (m1_c(3) and m1_c(2))) or (not (m1_c(3) or m1_c(2)) and not (m1_c(1) and m1_c(0)));
	m1_v	  <= m1_z xor m1_o;

	m0_c(0) <= x(0) xor x(1);
	m0_c(1) <= x(2) xor x(3);
	m0_c(2) <= x(4) xor x(5);
	m0_c(3) <= x(6) xor x(7);
	m0_o    <= (m0_c(1) and m0_c(0) and (m0_c(3) or m0_c(2))) or (m0_c(3) and m0_c(2) and (m0_c(1) or m0_c(0)));
	m0_z    <= (not (m0_c(1) or m0_c(0)) and not (m0_c(3) and m0_c(2))) or (not (m0_c(3) or m0_c(2)) and not (m0_c(1) and m0_c(0)));
	m0_v	  <= m0_z xor m0_o;
	
	m <= muxOut3(0) & muxOut2(0) & muxOut1(0) & muxOut0(0);
	v <= muxOut3(1) and muxOut2(1) and muxOut1(1) and muxOut0(1);
	
END parallel_decoder;

LIBRARY ieee;
USE ieee.std_logic_1164.all;

ENTITY decoder1m IS
	PORT (x:     IN  STD_LOGIC_VECTOR (7 DOWNTO 0);
			one:   OUT STD_LOGIC;
			valid: OUT STD_LOGIC);
END decoder1m;

ARCHITECTURE structure OF popCounter_4bit IS
	signal zero: 			  STD_LOGIC;
	signal c3, c2, c1, c0: STD_LOGIC;
BEGIN
	-- this is based in decoding for m3 (or m1 dependeing if you're looking at the problem as a bit word or a matrix)
	c0    <= x(0) xor x(1);
	c1    <= x(2) xor x(3);
	c2    <= x(4) xor x(5);
	c3    <= x(6) xor x(7);
	one   <= (c1 and c0 and (c3 or c2)) or (c3 and c2 and (c1 or c0))
	zero  <= (not (c1 or c0) and not (c3 and c2)) or (not (c3 or c2) and not (c1 and c0))
	valid <= one xor zero 
END structure;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
